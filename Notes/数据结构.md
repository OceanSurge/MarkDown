# 一、线性表

## 1.1、顺序表

![image-20210619180740210](../assets/数据结构/image-20210619180740210.png)

顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存 储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元 素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。

### 1.1.1、顺序表实现

**顺序表API设计：**

![image-20210618214951179](../assets/数据结构/image-20210618214951179.png)

### 1.1.2、顺序表遍历

一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。

在java中，遍历集合的方式一般都是用的是forEach循环，如果想让我们的SequenceList也能支持forEach循环，则 需要做如下操作： 

1. 让SequenceList实现Iterable接口，重写iterator方法；
2. 在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；

```java
public class SequenceList<T> implements Iterable<T> {

	//	线性表数据存储位置
	private T[] eles;
	//	元素个数
	private int N;

	//	构造函数
	public SequenceList(int capacity) {
//		初始化数组
		this.eles = (T[]) new Object[capacity];
//		初始化长度
		this.N = 0;
	}

	//	线性表置空
	public void clear() {
		this.N = 0;
	}

	//	判断当前线性表是否为空
	public boolean isEmpty() {
		return this.N == 0;
	}

	//	获取指定位置的元素
	public T get(int i) {
		if (i < 0 || i >= N) {
			throw new RuntimeException("当前元素不存在！");
		}
		return eles[i];
	}

	//	像线性表添加元素
	public void insert(T t) {
		if (N == eles.length) {
			throw new RuntimeException("当前表已满");
		}
		eles[N++] = t;
	}

	//	指定位置添加元素
	public void insert(int i, T t) {
		if (i == eles.length) {
			throw new RuntimeException("当前表已满");
		}
		if (i < 0 || i > N) {
			throw new RuntimeException("插入的位置不合法");
		}
//		i以后的元素后置
		for (int index = N; index > i; index--) {
			eles[index] = eles[index - 1];
		}
//		插入
		eles[i] = t;
		N++;
	}

	//	删除指定元素并返回
	public T remove(int i) {
		if (i < 0 || i > N - 1) {
			throw new RuntimeException("当前要删除的元素不存在");
		}
//		返回元素
		T current = eles[i];
//		元素前置
		for (int index = i; index < N - 1; index++) {
			eles[index] = eles[index + 1];
		}
//		长度减一
		N--;
		return current;
	}

	//	查询元素第一个索引
	public int indexOf(T t) {
		if (t == null) {
			throw new RuntimeException("查找的元素不合法");
		}
		for (int i = 0; i < N; i++) {
			if (eles[i].equals(t)) {
				return i;
			}
		}
		return -1;
	}

	@Override
	public String toString() {
		return "SequenceList{" +
				"eles=" + Arrays.toString(eles) +
				", N=" + N +
				'}';
	}

	@Override
	public Iterator<T> iterator() {
		return new SequenceListIterator();
	}

	private class SequenceListIterator implements Iterator {
		private int cusor;

		public SequenceListIterator() {
			this.cusor = 0;
		}

		@Override
		public boolean hasNext() {
			return cusor < N;
		}

		@Override
		public Object next() {
			return eles[cusor++];
		}
	}

}
```

### 1.1.3、顺序表容量可变

1. **添加元素时**

   添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我 们这里创建一个是原数组两倍容量的新数组存储元素。

2. **移除元素时**

    移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存 空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建 一个是原数组容量的1/2的新数组存储元素。

```java
//	数组扩容
	public void reSize(int newSize) {
//		定义临时数据指向原数组
		T[] temp = eles;
//		创建新数组
		eles = (T[]) new Object[newSize];
//		拷贝数据
		for (int i = 0; i < N; i++) {
			eles[i] = temp[i];
		}
	}
```

### 1.1.4、顺序便时间复杂度

- get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);
-  insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时 间复杂为O(n); 
- remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复 杂度为O(n); 
- 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺 序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题 越明显

### 1.1.5、5 java中ArrayList实现

java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。

## 1.2、链表

### 1.2.1、单向链表

![image-20210619180800082](../assets/数据结构/image-20210619180800082.png)

单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据， 指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。

- 单向链表API设计：

![image-20210619180431041](../assets/数据结构/image-20210619180431041.png)

- 单向链表代码实现：

```java
public class LinkList<T> implements Iterable<T> {
	//	记录头节点
	private Node head;
	//	链表长度
	private int N;


	private class Node {
		//		存储数据
		T item;
		//		下一个节点
		Node next;

		public Node(T item, Node next) {
			this.item = item;
			this.next = next;
		}
	}

	public LinkList() {
//		初始化头节点
		this.head = new Node(null, null);
//		初始化元素个数
		this.N = 0;

	}

	//	清空
	public void clear() {
		head.next = null;
		this.N = 0;
	}

	//	获取链表长度
	public int length() {
		return N;
	}

	//	判断链表是否为空
	public boolean isEmpty() {
		return N == 0;
	}

	//	获取指定位置节点
	public T get(int i) {
		Node node = head.next;
		for (int index = 0; index < i; index++) {
			node = node.next;
		}
		return node.item;
	}

	//	插入数据
	public void insert(T t) {
		Node node = head;
//		遍历找到最后一个节点
		while (node.next != null) {
			node = node.next;
		}
//		创建新节点
		Node newNode = new Node(t, null);
//		尾节点指向新节点
		node.next = newNode;
//		长度加一
		N++;
	}

	//	指定位置插入新节点
	public void insert(int i, T t) {
//		找到i位置前一个节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//      找到i位置节点
		Node curr = pre.next;

//      创建新节点，指向i节点
		Node newNode = new Node(t, curr);
//      i-1节点指向新节点
		pre.next = newNode;
//		长度加一
		N++;
	}

	//	删除指定位置节点
	public T remove(int i) {
//      找到i-1节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//		找到i节点
		Node curr = pre.next;
//		找到i+1节点
		Node nextNode = curr.next;
//		i-1节点指向i+1节点
		pre.next = nextNode;
//		长度减一
		N--;
		return curr.item;
	}

	//	查找元素位置
	public int indexOf(T t) {
		Node node = head;
		for (int index = 0; node.next != null; index++) {
			node = node.next;
			if (node.item.equals(t)) {
				return index;
			}
		}
		return -1;
	}


	@Override
	public Iterator<T> iterator() {
		return new LinkListIterator();
	}

	public class LinkListIterator implements Iterator {

		private Node node;

		public LinkListIterator() {
			this.node = head;
		}

		@Override
		public boolean hasNext() {
			return node.next != null;
		}

		@Override
		public Object next() {
			node = node.next;
			return node.item;
		}
	}

	@Override
	public String toString() {
		return "LinkList{" +
				"head=" + head +
				", N=" + N +
				'}';
	}
}
```

### 1.2.2、双向链表

双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用 来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存 储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。

![image-20210619180850412](../assets/数据结构/image-20210619180850412.png)

结点API设计

![image-20210619181037768](../assets/数据结构/image-20210619181037768.png)

双向链表API设计

![image-20210619181339972](../assets/数据结构/image-20210619181339972.png)

双向链表代码

```java
public class TwoWayLinkList<T> implements Iterable<T> {

	//	首节点
	private Node head;
	//	尾节点
	private Node last;
	//	长度
	private int N;

	//	节点类
	private class Node {

		//		数据
		private T item;
		//		前一节点
		private Node pre;
		//		后一节点
		private Node next;

		//		构造函数

		public Node(T item, Node pre, Node next) {
			this.item = item;
			this.pre = pre;
			this.next = next;
		}
	}

	//	构造函数
	public TwoWayLinkList() {
		this.head = new Node(null, null, null);
		this.last = null;
		this.N = 0;
	}

	//	清空链表
	private void clear() {
		this.head.next = null;
		this.head.pre = null;
		this.last = null;
		this.N = 0;
	}

	//	获取链表长度
	public int length() {
		return N;
	}

	//	判空
	public boolean isEmpty() {
		return N == 0;
	}

	//	获取第一个元素
	public T getFirst() {
		if (isEmpty()) {
			return null;
		}
		return head.next.item;
	}

	//	获取最后一个元素
	public T getLast() {
		if (isEmpty()) {
			return null;
		}
		return last.item;
	}

	//	插入元素
	public void insert(T t) {
		if (isEmpty()) {
//			如果链表为空，创建新节点，让其成为尾节点，头节点只想尾节点
			Node newNode = new Node(t, head, null);
			last = newNode;
			head.next = last;
		} else {
//			不为空，创建新节点让其成为尾节点
			Node oldLast = last;
			Node newNode = new Node(t, oldLast, null);
			oldLast.next = newNode;
			last = newNode;
		}
		N++;
	}

	//	指定位置插入
	public void insert(int i, T t) {
//		找到i-1节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//		找到i节点
		Node curr = pre.next;
//		创建新节点
		Node newNode = new Node(t, pre, curr);
//		i-1节点只相信节点
		pre.next = newNode;
//		i节点前一个节点指向新节点
		curr.pre = newNode;
		N++;
	}

	//	获取指定位置节点
	public T get(int i) {
		Node node = head.next;
		for (int index = 0; index < i; index++) {
			node = node.next;
		}
		return node.item;
	}

	//	查找元素位置
	public int indexOf(T t) {
		Node node = head;
		for (int index = 0; node.next != null; index++) {
			node = node.next;
			if (node.item.equals(t)) {
				return index;
			}
		}
		return -1;
	}

	//	删除指定元素
	public T remove(int i) {
//		i-1节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//		i节点
		Node curr = pre.next;
//		i+1节点
		Node nextNode = curr.next;
		pre.next = nextNode;
		nextNode.pre = pre;
		N--;
		return curr.item;
	}

	@Override
	public Iterator<T> iterator() {
		return new TwoWayLinkListIterator();
	}

	private class TwoWayLinkListIterator implements Iterator {

		private Node node;

		public TwoWayLinkListIterator() {
			this.node = head;
		}

		@Override
		public boolean hasNext() {
			return node.next != null;
		}

		@Override
		public Object next() {
			node = node.next;
			return node.item;
		}
	}

	@Override
	public String toString() {
		return "TwoWayLinkList{" +
				"head=" + head +
				", last=" + last +
				", N=" + N +
				'}';
	}
}
```

### 1.2.3 、链表的时间复杂度分析

-  get(int i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间 复杂度为O(n) 
- insert(int i,T t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的 元素越多，时间复杂度为O(n); 
- remove(int i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元 素越多，时间复杂度为O(n) 相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的， 它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,,同时它并没有涉及的元素的交换。 相比较顺序表，链表的查询操作性能会比较低。
- 因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删 操作比较多，建议使用链表。

### 1.2.4、单链表反转

![image-20210621092439467](../assets/数据结构/image-20210621092439467.png)

```java
//反转链表
	public void reverse() {
		if (isEmpty()) {
			return;
		}
		reverse(head.next);
	}

	/**
	 * 递归调用
	 *
	 * @param curr
	 * @return
	 */
	public Node reverse(Node curr) {
		if (curr.next == null) {
			head.next = curr;
			return curr;
		}
//		pre为curr节点的上一节点
		Node pre = reverse(curr.next);
		pre.next = curr;
		curr.next = null;
		return curr;
	}
```

### 1.2.5、快慢指针

#### 1.2.5.1、中间值

![image-20210621093820152](../assets/数据结构/image-20210621093820152.png)

```java
	/**
	 * @param first 链表的首结点
	 * @return 链表的中间结点的值
	 * 使用两个指针遍历链表，当快指针遍历到结尾，慢指针正好指向中间
	 */
	public T getMid(Node first) {
		Node slow = first;
		Node fast = first;
		while (fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
		}
		return slow.item;
	}
```

#### 1.2.5.2、单向链表是否有环


























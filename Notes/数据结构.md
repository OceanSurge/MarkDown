# 一、线性表

## 1.1、顺序表

![image-20210619180740210](../assets/数据结构/image-20210619180740210.png)

顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存 储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元 素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。

### 1.1.1、顺序表实现

**顺序表API设计：**

![image-20210618214951179](../assets/数据结构/image-20210618214951179.png)

### 1.1.2、顺序表遍历

一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。

在java中，遍历集合的方式一般都是用的是forEach循环，如果想让我们的SequenceList也能支持forEach循环，则 需要做如下操作： 

1. 让SequenceList实现Iterable接口，重写iterator方法；
2. 在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法；

```java
public class SequenceList<T> implements Iterable<T> {

	//	线性表数据存储位置
	private T[] eles;
	//	元素个数
	private int N;

	//	构造函数
	public SequenceList(int capacity) {
//		初始化数组
		this.eles = (T[]) new Object[capacity];
//		初始化长度
		this.N = 0;
	}

	//	线性表置空
	public void clear() {
		this.N = 0;
	}

	//	判断当前线性表是否为空
	public boolean isEmpty() {
		return this.N == 0;
	}

	//	获取指定位置的元素
	public T get(int i) {
		if (i < 0 || i >= N) {
			throw new RuntimeException("当前元素不存在！");
		}
		return eles[i];
	}

	//	像线性表添加元素
	public void insert(T t) {
		if (N == eles.length) {
			throw new RuntimeException("当前表已满");
		}
		eles[N++] = t;
	}

	//	指定位置添加元素
	public void insert(int i, T t) {
		if (i == eles.length) {
			throw new RuntimeException("当前表已满");
		}
		if (i < 0 || i > N) {
			throw new RuntimeException("插入的位置不合法");
		}
//		i以后的元素后置
		for (int index = N; index > i; index--) {
			eles[index] = eles[index - 1];
		}
//		插入
		eles[i] = t;
		N++;
	}

	//	删除指定元素并返回
	public T remove(int i) {
		if (i < 0 || i > N - 1) {
			throw new RuntimeException("当前要删除的元素不存在");
		}
//		返回元素
		T current = eles[i];
//		元素前置
		for (int index = i; index < N - 1; index++) {
			eles[index] = eles[index + 1];
		}
//		长度减一
		N--;
		return current;
	}

	//	查询元素第一个索引
	public int indexOf(T t) {
		if (t == null) {
			throw new RuntimeException("查找的元素不合法");
		}
		for (int i = 0; i < N; i++) {
			if (eles[i].equals(t)) {
				return i;
			}
		}
		return -1;
	}

	@Override
	public String toString() {
		return "SequenceList{" +
				"eles=" + Arrays.toString(eles) +
				", N=" + N +
				'}';
	}

	@Override
	public Iterator<T> iterator() {
		return new SequenceListIterator();
	}

	private class SequenceListIterator implements Iterator {
		private int cusor;

		public SequenceListIterator() {
			this.cusor = 0;
		}

		@Override
		public boolean hasNext() {
			return cusor < N;
		}

		@Override
		public Object next() {
			return eles[cusor++];
		}
	}

}
```

### 1.1.3、顺序表容量可变

1. **添加元素时**

   添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我 们这里创建一个是原数组两倍容量的新数组存储元素。

2. **移除元素时**

    移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存 空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建 一个是原数组容量的1/2的新数组存储元素。

```java
//	数组扩容
	public void reSize(int newSize) {
//		定义临时数据指向原数组
		T[] temp = eles;
//		创建新数组
		eles = (T[]) new Object[newSize];
//		拷贝数据
		for (int i = 0; i < N; i++) {
			eles[i] = temp[i];
		}
	}
```

### 1.1.4、顺序便时间复杂度

- get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);
-  insert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时 间复杂为O(n); 
- remove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复 杂度为O(n); 
- 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺 序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题 越明显

### 1.1.5、5 java中ArrayList实现

java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。

## 1.2、链表

### 1.2.1、单向链表

![image-20210619180800082](../assets/数据结构/image-20210619180800082.png)

单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据， 指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。

- 单向链表API设计：

![image-20210619180431041](../assets/数据结构/image-20210619180431041.png)

- 单向链表代码实现：

```java
public class LinkList<T> implements Iterable<T> {
	//	记录头节点
	private Node head;
	//	链表长度
	private int N;


	private class Node {
		//		存储数据
		T item;
		//		下一个节点
		Node next;

		public Node(T item, Node next) {
			this.item = item;
			this.next = next;
		}
	}

	public LinkList() {
//		初始化头节点
		this.head = new Node(null, null);
//		初始化元素个数
		this.N = 0;

	}

	//	清空
	public void clear() {
		head.next = null;
		this.N = 0;
	}

	//	获取链表长度
	public int length() {
		return N;
	}

	//	判断链表是否为空
	public boolean isEmpty() {
		return N == 0;
	}

	//	获取指定位置节点
	public T get(int i) {
		Node node = head.next;
		for (int index = 0; index < i; index++) {
			node = node.next;
		}
		return node.item;
	}

	//	插入数据
	public void insert(T t) {
		Node node = head;
//		遍历找到最后一个节点
		while (node.next != null) {
			node = node.next;
		}
//		创建新节点
		Node newNode = new Node(t, null);
//		尾节点指向新节点
		node.next = newNode;
//		长度加一
		N++;
	}

	//	指定位置插入新节点
	public void insert(int i, T t) {
//		找到i位置前一个节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//      找到i位置节点
		Node curr = pre.next;

//      创建新节点，指向i节点
		Node newNode = new Node(t, curr);
//      i-1节点指向新节点
		pre.next = newNode;
//		长度加一
		N++;
	}

	//	删除指定位置节点
	public T remove(int i) {
//      找到i-1节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//		找到i节点
		Node curr = pre.next;
//		找到i+1节点
		Node nextNode = curr.next;
//		i-1节点指向i+1节点
		pre.next = nextNode;
//		长度减一
		N--;
		return curr.item;
	}

	//	查找元素位置
	public int indexOf(T t) {
		Node node = head;
		for (int index = 0; node.next != null; index++) {
			node = node.next;
			if (node.item.equals(t)) {
				return index;
			}
		}
		return -1;
	}


	@Override
	public Iterator<T> iterator() {
		return new LinkListIterator();
	}

	public class LinkListIterator implements Iterator {

		private Node node;

		public LinkListIterator() {
			this.node = head;
		}

		@Override
		public boolean hasNext() {
			return node.next != null;
		}

		@Override
		public Object next() {
			node = node.next;
			return node.item;
		}
	}

	@Override
	public String toString() {
		return "LinkList{" +
				"head=" + head +
				", N=" + N +
				'}';
	}
}
```

### 1.2.2、双向链表

双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用 来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存 储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。

![image-20210619180850412](../assets/数据结构/image-20210619180850412.png)

结点API设计

![image-20210619181037768](../assets/数据结构/image-20210619181037768.png)

双向链表API设计

![image-20210619181339972](../assets/数据结构/image-20210619181339972.png)

双向链表代码

```java
public class TwoWayLinkList<T> implements Iterable<T> {

	//	首节点
	private Node head;
	//	尾节点
	private Node last;
	//	长度
	private int N;

	//	节点类
	private class Node {

		//		数据
		private T item;
		//		前一节点
		private Node pre;
		//		后一节点
		private Node next;

		//		构造函数

		public Node(T item, Node pre, Node next) {
			this.item = item;
			this.pre = pre;
			this.next = next;
		}
	}

	//	构造函数
	public TwoWayLinkList() {
		this.head = new Node(null, null, null);
		this.last = null;
		this.N = 0;
	}

	//	清空链表
	private void clear() {
		this.head.next = null;
		this.head.pre = null;
		this.last = null;
		this.N = 0;
	}

	//	获取链表长度
	public int length() {
		return N;
	}

	//	判空
	public boolean isEmpty() {
		return N == 0;
	}

	//	获取第一个元素
	public T getFirst() {
		if (isEmpty()) {
			return null;
		}
		return head.next.item;
	}

	//	获取最后一个元素
	public T getLast() {
		if (isEmpty()) {
			return null;
		}
		return last.item;
	}

	//	插入元素
	public void insert(T t) {
		if (isEmpty()) {
//			如果链表为空，创建新节点，让其成为尾节点，头节点只想尾节点
			Node newNode = new Node(t, head, null);
			last = newNode;
			head.next = last;
		} else {
//			不为空，创建新节点让其成为尾节点
			Node oldLast = last;
			Node newNode = new Node(t, oldLast, null);
			oldLast.next = newNode;
			last = newNode;
		}
		N++;
	}

	//	指定位置插入
	public void insert(int i, T t) {
//		找到i-1节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//		找到i节点
		Node curr = pre.next;
//		创建新节点
		Node newNode = new Node(t, pre, curr);
//		i-1节点只相信节点
		pre.next = newNode;
//		i节点前一个节点指向新节点
		curr.pre = newNode;
		N++;
	}

	//	获取指定位置节点
	public T get(int i) {
		Node node = head.next;
		for (int index = 0; index < i; index++) {
			node = node.next;
		}
		return node.item;
	}

	//	查找元素位置
	public int indexOf(T t) {
		Node node = head;
		for (int index = 0; node.next != null; index++) {
			node = node.next;
			if (node.item.equals(t)) {
				return index;
			}
		}
		return -1;
	}

	//	删除指定元素
	public T remove(int i) {
//		i-1节点
		Node pre = head;
		for (int index = 0; index < i; index++) {
			pre = pre.next;
		}
//		i节点
		Node curr = pre.next;
//		i+1节点
		Node nextNode = curr.next;
		pre.next = nextNode;
		nextNode.pre = pre;
		N--;
		return curr.item;
	}

	@Override
	public Iterator<T> iterator() {
		return new TwoWayLinkListIterator();
	}

	private class TwoWayLinkListIterator implements Iterator {

		private Node node;

		public TwoWayLinkListIterator() {
			this.node = head;
		}

		@Override
		public boolean hasNext() {
			return node.next != null;
		}

		@Override
		public Object next() {
			node = node.next;
			return node.item;
		}
	}

	@Override
	public String toString() {
		return "TwoWayLinkList{" +
				"head=" + head +
				", last=" + last +
				", N=" + N +
				'}';
	}
}
```

### 1.2.3 、链表的时间复杂度分析

-  get(int i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间 复杂度为O(n) 
- insert(int i,T t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的 元素越多，时间复杂度为O(n); 
- remove(int i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元 素越多，时间复杂度为O(n) 相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的， 它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,,同时它并没有涉及的元素的交换。 相比较顺序表，链表的查询操作性能会比较低。
- 因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删 操作比较多，建议使用链表。

### 1.2.4、单链表反转

![image-20210621092439467](../assets/数据结构/image-20210621092439467.png)

```java
//反转链表
	public void reverse() {
		if (isEmpty()) {
			return;
		}
		reverse(head.next);
	}

	/**
	 * 递归调用
	 *
	 * @param curr
	 * @return
	 */
	public Node reverse(Node curr) {
		if (curr.next == null) {
			head.next = curr;
			return curr;
		}
//		pre为curr节点的上一节点
		Node pre = reverse(curr.next);
		pre.next = curr;
		curr.next = null;
		return curr;
	}
```

### 1.2.5、快慢指针

#### 1.2.5.1、中间值

![image-20210621093820152](../assets/数据结构/image-20210621093820152.png)

```java
	/**
	 * @return 链表的中间结点的值
	 * 使用两个指针遍历链表，当快指针遍历到结尾，慢指针正好指向中间
	 */
	public T getMid() {
		Node slow = this.head;
		Node fast = this.head;
		while (fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
		}
		return slow.item;
	}
```

#### 1.2.5.2、单向链表是否有环

![image-20210621181444587](../assets/数据结构/image-20210621181444587.png)

```java
	/**
	 * @return 是否有环
	 * 判断是否有环
	 */
	public boolean isCircle() {
//		定义快慢指针
		Node fast = this.head;
		Node slow = this.head;
		while (fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
			if (fast.equals(slow)) {
				return true;
			}
		}
		return false;
	}
```

#### 1.2.5.3、有环链表入口

- 当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样 为1，则慢指针与“新”指针相遇的地方就是环的入口。
- 证明这一结论牵涉到数论的知识，这里略，只讲实现。

![image-20210621183430482](../assets/数据结构/image-20210621183430482.png)

```java
	/**
	 * 环的入口
	 *
	 * @return 环的入口
	 */
	public Node getEntrance() {
//		定义指针
		Node fast = this.head;
		Node slow = this.head;
		Node temp = null;
//		判断是否有环
		while (fast != null && fast.next != null) {
			fast = fast.next.next;
			slow = slow.next;
			if (fast.equals(slow)) {
				temp = this.head;
				continue;
			}
			if (temp != null) {
				temp = temp.next;
				if (temp.equals(slow)) {
					return temp;
				}
			}
		}
		return null;
	}
```

### 1.2.6、约瑟夫问题

- **问题描述：** 

  传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决 定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往 后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡 为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与 第31个位置，从而逃过了这场死亡游戏 。 

- **问题转换：** 

  41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。 1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈； 2.自退出那个人开始的下一个人再次从1开始报数，以此类推； 3.求出最后退出的那个人的编号。

-  **图示：**

  ![image-20210621190542375](../assets/数据结构/image-20210621190542375.png)

- **代码实现：**

  ```java
  public class JosephTest {
  	public static void main(String[] args) {
  		//1.构建循环链表
  		Node<Integer> first = null;
  		//记录前一个结点
  		Node<Integer> pre = null;
  		for (int i = 1; i <= 41; i++) {
  			//第一个元素
  			if (i == 1) {
  				first = new Node(i, null);
  				pre = first;
  				continue;
  			}
  			Node<Integer> node = new Node<>(i, null);
  			pre.next = node;
  			pre = node;
  			if (i == 41) {
  				//构建循环链表，让最后一个结点指向第一个结点
  				pre.next = first;
  			}
  		}
  		//2.使用count，记录当前的报数值
  		int count = 0;
  		//3.遍历链表，每循环一次，count++
  		Node<Integer> n = first;
  		Node<Integer> before = null;
  		while (n != n.next) {
  			//4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；
  			count++;
  			if (count == 3) {
  				//删除当前结点
  				before.next = n.next;
  				System.out.print(n.item + ",");
  				count = 0;
  				n = n.next;
  			} else {
  				before = n;
  				n = n.next;
  			}
  		}
  		//		打印剩余的最后那个人
  		System.out.println(n.item);
  	}
  
  	public static class Node<T> {
  		T item;
  		Node<T> next;
  
  		public Node(T item, Node<T> next) {
  			this.item = item;
  			this.next = next;
  		}
  	}
  }
  ```

## 1.3、栈

- 栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出 的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一 个数据被第一个读出来）。
-  我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。

### 1.3.1、链栈实现

- 链栈API：

  ![image-20210621200047689](../assets/数据结构/image-20210621200047689.png)

- 代码实现：

  ```java
  import java.util.Iterator;
  
  public class NodeStack<T> implements Iterable<T> {
  
  	//	首节点
  	private Node head;
  	//	栈中元素个数
  	private int N;
  
  	private class Node {
  		T item;
  		Node next;
  
  		public Node(T item, Node next) {
  			this.item = item;
  			this.next = next;
  		}
  	}
  
  	public NodeStack() {
  		this.head = new Node(null, null);
  		this.N = 0;
  	}
  
  	//	判空
  	public boolean isEmpty() {
  		return this.N == 0;
  	}
  
  	//	元素个数
  	public int size() {
  		return this.N;
  	}
  
  	//	压栈
  	public void push(T t) {
  		Node oleNode = head.next;
  		Node newNode = new Node(t, oleNode);
  		head.next = newNode;
  		this.N++;
  	}
  
  	//	出栈
  	public T pop() {
  		Node oleNode = head.next;
  		if (oleNode == null) {
  			return null;
  		}
  		head.next = oleNode.next;
  		N--;
  		return oleNode.item;
  	}
  
  	@Override
  	public Iterator<T> iterator() {
  		return new NodeStackIterator();
  	}
  
  	private class NodeStackIterator implements Iterator {
  
  		private Node node;
  
  		public NodeStackIterator() {
  			this.node = head;
  		}
  
  		@Override
  		public boolean hasNext() {
  			return node.next != null;
  		}
  
  		@Override
  		public Object next() {
  			node = node.next;
  			return node.item;
  		}
  	}
  }
  ```

### 1.3.2、括号匹配问题

- 问题描述：

  ```java
  给定一个字符串，里边可能包含"()"小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。
  例如：
  	"(上海)(长安)"：正确匹配
  	"上海((长安))"：正确匹配
  	"上海(长安(北京)(深圳)南京)":正确匹配
  	"上海(长安))"：错误匹配
  	"((上海)长安"：错误匹配
  ```

- 代码实现：

  ```java
  /**
   * 括号匹配问题
   */
  
  public class BracketMatchTest {
  	public static void main(String[] args) {
  		String str = "(上海(长安)())";
  		boolean match = isMatch(str);
  		System.out.println(str + "中的括号是否匹配：" + match);
  	}
  
  	/**
  	 * 判断str中的括号是否匹配
  	 *
  	 * @param str 括号组成的字符串
  	 * @return 如果匹配，返回true，如果不匹配，返回false
  	 */
  	public static boolean isMatch(String str) {
  //		创建栈
  		NodeStack<String> chars = new NodeStack<>();
  //		遍历字符串
  		for (int i = 0; i < str.length(); i++) {
  			String currChar = str.charAt(i) + "";
  //			判断当前字符是否为左括号，压入栈
  			if (currChar.equals("(")) {
  				chars.push(currChar);
  			} else if (currChar.equals(")")) {
  //				判断是否右括号，是则弹栈，判断弹出值是否为空
  				String pop = chars.pop();
  				if (pop == null) {
  					return false;
  				}
  			}
  		}
  		if (chars.size() == 0) {
  			return true;
  		} else {
  			return false;
  		}
  	}
  }
  ```

### 1.3.3、逆波兰表达式求值

- **中缀表达式：**

   中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总 是置于两个操作数中间。

   中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的 运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做 大量的优先级相关操作。

-  **逆波兰表达式(后缀表达式)：** 

  逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表 达式的特点：运算符总是放在跟它相关的操作数之后。

  ![image-20210621211627917](../assets/数据结构/image-20210621211627917.png)

- **需求：**

  给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。

  ```java
  public class ReversePolishNotation {
  	public static void main(String[] args) {
  //中缀表达式3*（17-15）+18/6的逆波兰表达式如下
  		String[] notation = {"3", "17", "15", "-", "*","18", "6","/","+"};
  		int result = caculate(notation);
  		System.out.println("逆波兰表达式的结果为："+result);
  	}
  	/**
  	 * @param notaion 逆波兰表达式的数组表示方式
  	 * @return 逆波兰表达式的计算结果
  	 */
  	public static int caculate(String[] notaion){
  		return -1;
  	}
  }
  ```

- **分析：**

  ```java
  1.创建一个栈对象oprands存储操作数
  2.从左往右遍历逆波兰表达式，得到每一个字符串
  3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中
  4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2
  5.使用该运算符计算o1和o2，得到结果result
  6.把该结果压入oprands栈中
  7.遍历结束后，拿出栈中最终的结果返回
  ```

  ![image-20210621211800590](../assets/数据结构/image-20210621211800590.png)

- 代码实现：

  ```java
  
  ```

  

































